package tpfinalMDC;

import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Stack;

import javax.swing.JPanel;

import tpfinalMDC.deduction.ErreurFileVide;
import tpfinalMDC.deduction.ErreurPileVide;
import tpfinalMDC.deduction.Et;
import tpfinalMDC.deduction.Expression1;
import tpfinalMDC.deduction.File;
import tpfinalMDC.deduction.FinD;
import tpfinalMDC.deduction.Implication;
import tpfinalMDC.deduction.JetonDeduction;
import tpfinalMDC.deduction.Liste;
import tpfinalMDC.deduction.NegationD;
import tpfinalMDC.deduction.Node;
import tpfinalMDC.deduction.Operateur;
import tpfinalMDC.deduction.OperateurB;
import tpfinalMDC.deduction.OperateurU;
import tpfinalMDC.deduction.Ou;
import tpfinalMDC.deduction.ParentheseF;

import tpfinalMDC.deduction.ParentheseO;

import tpfinalMDC.deduction.Pile;
import tpfinalMDC.deduction.VariableD;

/**
 *
 * @author The one
 */
public class Menu extends javax.swing.JFrame {

    /**
     * Creates new form Menu
     */
    public Menu() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        titre = new javax.swing.JLabel();
        demontrer = new javax.swing.JButton();
        menuediteur = new javax.swing.JScrollPane();
        editeur = new javax.swing.JTextArea();
        menuOption = new javax.swing.JScrollPane();
        option = new javax.swing.JList<>();
        menuerreur = new javax.swing.JScrollPane();
        erreur = new javax.swing.JTextArea();
        titreErreur = new javax.swing.JLabel();
        affichage = new javax.swing.JScrollPane();
     
        negation = new javax.swing.JButton();
        et = new javax.swing.JButton();
        ou = new javax.swing.JButton();
        implication = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        titre.setBackground(new java.awt.Color(51, 255, 204));
        titre.setFont(new java.awt.Font("Tahoma", 1, 48)); // NOI18N
        titre.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        titre.setText("TP FINAL MDC");

        demontrer.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        demontrer.setText("Démontrer");
        demontrer.setToolTipText("");
        demontrer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                try {
					demontrerActionPerformed(evt);
				} catch (ErreurFileVide e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
            }
        });
        negation.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                negationActionPerformed(evt);
            }
        });
        et.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                etActionPerformed(evt);
            }
        });
        ou.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ouActionPerformed(evt);
            }
        });



        editeur.setColumns(20);
        editeur.setRows(5);
        menuediteur.setViewportView(editeur);

        option.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "Deduction", "Resolution" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        option.setSelectedIndex(1);
        option.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        menuOption.setViewportView(option);

        erreur.setEditable(false);
        erreur.setColumns(20);
        erreur.setRows(5);
        menuerreur.setViewportView(erreur);

        titreErreur.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        titreErreur.setText("Erreur :");
        titreErreur.setToolTipText("");

       

        negation.setFont(new java.awt.Font("Tahoma", 1, 10)); // NOI18N
        negation.setText("Négation");

        et.setFont(new java.awt.Font("Tahoma", 1, 10)); // NOI18N
        et.setText("ET");
        et.setToolTipText("");

        ou.setFont(new java.awt.Font("Tahoma", 1, 10)); // NOI18N
        ou.setText("OU");
        ou.setToolTipText("");

        implication.setFont(new java.awt.Font("Tahoma", 1, 10)); // NOI18N
        implication.setText("Implication");
        implication.setToolTipText("");
        implication.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                implicationActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(55, 55, 55)
                        .addComponent(menuOption, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(titre, javax.swing.GroupLayout.PREFERRED_SIZE, 650, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(10, 10, 10)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(negation)
                                        .addGap(75, 75, 75)
                                        .addComponent(et, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(82, 82, 82)
                                        .addComponent(ou, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(implication))
                                    .addComponent(menuediteur, javax.swing.GroupLayout.PREFERRED_SIZE, 540, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addComponent(demontrer, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(52, 52, 52)
                        .addComponent(titreErreur, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(menuerreur, javax.swing.GroupLayout.PREFERRED_SIZE, 642, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(55, 55, 55)
                        .addComponent(affichage, javax.swing.GroupLayout.PREFERRED_SIZE, 783, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(0, 46, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(titre, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addComponent(demontrer, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(20, 20, 20)
                                .addComponent(menuOption, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(71, 71, 71))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(menuediteur, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(13, 13, 13)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(negation)
                            .addComponent(et)
                            .addComponent(ou)
                            .addComponent(implication))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))
                .addComponent(affichage, javax.swing.GroupLayout.PREFERRED_SIZE, 363, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(titreErreur, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(29, 29, 29))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(menuerreur, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())))
        );

        pack();
        this.setResizable(false);
    }// </editor-fold>                        
    public String divide(String s) {
    	String[] t=s.split("\n");
        String[] k;
        String code = "";
        for(int i=0;i<t.length;i++) {
     	k=t[i].split(" ");
     	 for(int j=0;j<k.length;j++) {
     	    	code=code.concat(k[j]);
     	       }
        }
        return code;
    }
    public void erreur(int k,String c) {
    	switch(k) {
    		case 0: erreur.append((er+1)+"- Erreur l'expression ne doit pas etre vide ("+c+")\n");
    				er++; break;
    		case 1: erreur.append((er+1)+"- Erreur l'expression doit contenir au moins une clause non vide ("+c+")\n");
    		            er++; break;
    		case 2:erreur.append((er+1)+"- Erreur Lexicale caractere Illégale ("+c+")\n");
                          er++; break;
    		case 3:erreur.append((er+1)+"- L'expression saisie est syntaxiquement incorrect \n");
                      er++; break;
    		case 4:erreur.append((er+1)+"- L'expression saisie contient une négation sans opérande \n");
            er++; break;
    		case 5:erreur.append((er+1)+"- Une des clauses contient un terme manquant \n");
            er++; break;
    		case 6:erreur.append((er+1)+"- Duplication du terme ("+c+") dans une clause \n");
            er++; break;
    		case 7:erreur.append((er+1)+"- Existance de l'opposée du terme ("+c+") dans la meme clause \n");
            er++; break;
    	}
    }
    public void erreur1(int k,String c) {
    	switch(k) {
    		case 0: erreur.append((er+1)+"- Erreur l'expression ne doit pas etre vide ("+c+")\n");
    				er++; break;
    		case 1: erreur.append((er+1)+"- Erreur l'expression doit contenir au moins une clause non vide ("+c+")\n");
    		            er++; break;
    		case 2:erreur.append((er+1)+"- Erreur Lexicale caractere Illégale ("+c+")\n");
                          er++; break;
    		case 3:erreur.append((er+1)+"- L'expression saisie est syntaxiquement incorrect \n");
                      er++; break;
    		case 4:erreur.append((er+1)+"- L'expression saisie contient une négation sans opérande \n");
            er++; break;
    		case 5:erreur.append((er+1)+"- Une des clauses contient un terme manquant \n");
            er++; break;
    		case 6:erreur.append((er+1)+"- Duplication du terme ("+c+") dans une clause \n");
            er++; break;
    		case 7:erreur.append((er+1)+"- Existance de l'opposée du terme ("+c+") dans la meme clause \n");
            er++; break;
    		case 8:erreur.append((er+1)+"- Il manque ("+c+") parentheses ouvrantes \n");
            er++; break;
    		case 9:erreur.append((er+1)+"- Il manque ("+c+") parentheses fermantes \n");
            er++; break;
            
    	}
    }
    public boolean lettre(char ch) {
    	if((ch >= 'a' && ch <= 'z')){
    	     return true;
    	    }
    	        else{
    	        return false;
    	    }
    }
    public void lexicale(String s) {
           int l=s.length(); p=0;er=0;
           while(p<l) {
        	   char  m=s.charAt(p);
        	   String c=""+m;
        	   switch(c) {
        	   case"{": entree.add(new AccoladeO("{"));
        	                p++;
        	                break;
        	   case"}": entree.add(new AccoladeF("}"));
        	   					p++;
        	   					break;
        	   case"¬": String k="¬";
        	            p++;
        	            if(lettre(s.charAt(p))){
        	            	k=k+s.charAt(p);
        	            	entree.add(new Variable(k));
        	            	p++;
        	            }else {
        	            	entree.add(new Negation(k));
        	            }
        	            break;
        	   case",": entree.add(new Separator(","));
        	                       p++;
        	                       break;
        	   case  "a":  case  "b":  case  "c":  case  "d":  case  "e":  case  "f":  case  "g":case  "h":  case  "i":  case  "j":  case  "k":  case  "l":  case  "m":  case  "n":case  "o":  case  "p":  case  "q":  case  "r":  case  "s":  case  "t":  case  "u":case  "v":  case  "w":  case  "x":  case  "y":  case  "z":
        	       entree.add(new Variable(c)); 
        	       p++;
        	       break;
        	   default: 
        		    erreur(2,c);
        		      p++;
        	   }//fin du switch
        	   
           }	
    }//fin de l'analyse lexicale
    public void lexicale1(String s) {
        int l=s.length(); p=0;er=0;
        while(p<l) {
     	   char  m=s.charAt(p);
     	   String c=""+m;
     	   switch(c) {
     	   case"(": entree1.add(new ParentheseO("("));
     	                p++;
     	                break;
     	   case")": entree1.add(new ParentheseF(")"));
     	   					p++;
     	   					break;
     	   case"¬": entree1.add(new NegationD(c));
     	                      p++;
     	            break;
    	   case"⇒": entree1.add(new Implication(c));
    	                   p++;
            break;
    	   case"∧": entree1.add(new Et(c));
    	   					p++;
    	   				    break;
    	   case "∨":entree1.add(new Ou(c));
    	                   p++;
            break;
     	   case  "a":  case  "b":  case  "c":  case  "d":  case  "e":  case  "f":  case  "g":case  "h":  case  "i":  case  "j":  case  "k":  case  "l":  case  "m":  case  "n":case  "o":  case  "p":  case  "q":  case  "r":  case  "s":  case  "t":  case  "u":case  "v":  case  "w":  case  "x":  case  "y":  case  "z":
     	       entree1.add(new VariableD(c)); 
     	       p++;
     	       break;
     	   default: 
     		    erreur1(2,c);
     		      p++;
     	   }//fin du switch
     	   
        }	
 }//fin de l'analyse lexicale
    
    
    public void T() {
    //	System.out.println("On est la");
    	 c=suivant();
      if(c instanceof AccoladeO) {
    	  F();
    	  c=suivant();
    	  if(c instanceof AccoladeF) {
    		  c=suivant();
    		  if(c instanceof fin) {
    			  
    		  }else {
    			  if(er==0) {
    			  erreur(3," ");}
    		  }
    	  }else {
    		  if(er==0) {
    		  erreur(3," ");
    		  }
    	  }
      }else {
    	  if(er==0) {
    	  erreur(3," ");
    	  }
      }
    }//fin de l'axiome
    
    public void F() {
    //	System.out.println("On est la 2");
    	clause=new Clause(Integer.toString(number));
    	number++;
    	C();
    	expression.ajouter(clause);
    	c=suivant();
    	if(c instanceof Separator) {
    		F();
    	}
    	else if(c instanceof AccoladeF) {
    		
    		p--;
    	}else {
    		  if(er==0) {
    		  erreur(3," ");
    		  }
    	}
    }
    
    public void C() {
    	//System.out.println("On est la 3");
    	c=suivant();
    	//c.affiche();
    	if(c instanceof AccoladeO) {
    		E();
    		c=suivant();
    		if(c instanceof AccoladeF) {
    			
    		}else {
    			  if(er==0) {
    			  erreur(3," ");
    			  }
    		}
    	}else {
    		  if(er==0) {
    		  erreur(3," ");
    		  }
    	}
    }
    public void E() {
    	//System.out.println("On est la 4");
    	Var();
    	//System.out.println("retour la 4");
    	c=suivant();
    	//c.affiche();
    	
    	if(c instanceof Separator) {
    		E();
    	}
    	else if(c instanceof AccoladeF) {
    		p--;
    	}else {
    		  if(er==0) {
    		  erreur(3," ");
    		  }
    	}
    }
    public void Var() {
    	//System.out.println("On est la 5");
    	c=suivant();
    	//c.affiche();
    	if(c instanceof Variable) {
    		clause.affichedemonstration();
    		if(clause.existe((Variable) c)==false) {
    			if(clause.existe(c.oppose())==false) {
    		clause.ajouter((Variable) c);
    			}else {
    				 if(er==0) {
    		    			erreur(7,c.getval());
    		    			 }
    			}
    		}else {
    			 if(er==0) {
    			erreur(6,c.getval());
    			 }
    		}
    	}else {
    		if(c instanceof Negation) {
    			  if(er==0) {
    			erreur(4,"");
    			  }
    		}else if(c instanceof AccoladeF){
    			  if(er==0) {
    			erreur(5,"");
    			  }
    		}else {
    			  if(er==0) {
    			 erreur(3," ");
    			  }
    		}
    	}
    }
    public boolean existeElimination(Clause c1,Clause c2) {
    	int i=0; boolean tr=false;
    	while(i<c1.taille() && tr==false) {
    		
    		if(c2.existe(c1.getVariable(i).oppose())) {
    			tr=true;
    		}else {
    			i++;
    		}		
    	}
    	return tr;
    }//fin de la methode existe elimination
    
    public void   afficheClause(Clause r) {
    	ecran1.append("{");
    	for(int i=0;i<r.taille();i++) {
    		if(i!=0) {
    			ecran1.append(" , ");
    		}
    		ecran1.append(r.getVariable(i).getval()) ;
    	}
    	ecran1.append("} \n");
    }
    public void afficheFormule(Expression e) {
    
    	for(int i=0;i<e.taille();i++) {
    		ecran1.append(e.getClause(i).getNum()+" = ");
    		afficheClause(e.getClause(i));
    	}
    }
  
   public void resolution() {
	   ecran1.setText("");
	   afficheFormule(expression);
	   boolean trouve=false;
	      int i=0; int l=this.expression.taille();int compteur1=1;
	       
	     while(i<l && trouve==false) {
	    	 Expression copie=expression.copie();
	    	// System.out.println("oh mygod");
	    			copie.affiche();
	    		//	System.out.println("please");
	    	
	    	
	    	 Clause r=expression.getClause(i);
	    	 copie.enlever(i);
	    		//copie.affiche();
	    	 String num=r.getNum();
	    	 int j=0;
	    	 int compteur=0;
	    	 while(j<copie.taille() && trouve==false) {
	    		
	    		   Clause k=copie.getClause(j);
	    		   if(existeElimination(k,r)) {
	    			  
	    			   if(compteur==0) {
	    				   ecran1.append("Possibilité N°"+(compteur1)+"\n");
	    				   compteur1++;
	    			   ecran1.append(""+num+""+k.getNum()+" = R1 \n");
	    			   compteur++;
	    			   }else {
	    				   ecran1.append("R"+(compteur)+""+k.getNum()+" = R"+(compteur+1)+"\n");
	    				   compteur++;
	    			   }
	    		   for(int x=0;x<k.taille();x++) {
	    			   if(r.existe(k.getVariable(x).oppose())) {
	    				                  r.enlever(r.position(k.getVariable(x).oppose()));
	    				                 
	    			           }else if(!r.existe(k.getVariable(x))) {
	    			        	   r.ajouter(k.getVariable(x));
	    			           }
	    		                                  }//fin de la boucle for
	    		   if(r.clausevide()) {
	    			   trouve=true;
	    		   }
	    		   ecran1.append("R"+(compteur)+" = ");
	    		   afficheClause(r);
	    		                              }//fin de existe elimination
	    		   else {
	    			 
	    		   }
	    		 j++;
	    	 }//fin de la deuxieme boucle
	    	 
	    	 i++;
	     }//fin de la premiere boucle
	     
	     if(trouve==false) {
	    	 ecran1.append("La formule n'est pas vérifié \n");
	     }else {
	    	 ecran1.append("La formule est vérifié \n");
	     }
	     
   }
   
 public void S() {
	 E1();
	 c1=suivant1();
	 if(c1 instanceof FinD) {
		 if(paren==0) {
			 
		 }else {
			 if(paren>0) {
				 if(er==0) {
			   		  erreur1(9,Integer.toString(paren));
			   		  } 
			 }else {
				 if(er==0) {
			   		  erreur1(8,Integer.toString((paren*(-1))));
			   		  } 
			 }
		 }
		 
	 }else {
		 if(er==0) {
	   		  erreur1(3," ");
	   		  } 
	 }
 }
 int mp=1;
 public void E1() {
	 c1=suivant1();
	
	 mp++;
	 if(c1 instanceof NegationD) {
/**********************************************Negation ********************************************************/
		 OpU();
		 c1=suivant1();
         if(c1 instanceof ParentheseO) {
                     paren++;
        	 E1();
    		 c1=suivant1();
    		 if(c1 instanceof ParentheseF) {
    			 paren--;
    		 }else if (c1 instanceof OperateurB) {
    			 OpB();
    			 E1();
    		 }else if(c1 instanceof FinD) {
    			 p--;
    		 }else {
    			 if(er==0) {
    		   		  erreur1(3," ");
    		   		  } 
    		 }
   
         }else if(c1 instanceof VariableD ) {
       
        	 Var1();
        	 c1=suivant1();
        	 if(c1 instanceof FinD) {
        		 p--;
        	 }else if(c1 instanceof OperateurB) {
        		 E1();
        	 }else if(c1 instanceof ParentheseF) {
        		 p--;
        	 }
        		 else {
        		 if(er==0) {
   		   		  erreur1(3," ");
   		   		  } 
        	 }
         }else {
        	 if(er==0) {
		   		  erreur1(3," ");
		   		  } 
         }
	 }else if (c1 instanceof VariableD) {
		 
	 /**********************************************Variable ********************************************************/
		 Var1();
		 c1=suivant1();
		 if(c1 instanceof ParentheseF) {
			 paren--;
		 }else if (c1 instanceof OperateurB) {
			 OpB();
			 E1();
		 }else if(c1 instanceof FinD) {
			 p--;
		 }else {
			 if(er==0) {
		   		  erreur1(3," ");
		   		  } 
		 }
	 /**********************************************Variable ********************************************************/
	 }else if(c1 instanceof ParentheseO){
		 paren++;
/**********************************************Parenthese Ouvrante ********************************************************/
		 E1();
		
		 c1=suivant1();
		
		 if(c1 instanceof ParentheseF) {
			 paren--;
		 }else if (c1 instanceof OperateurB) {
			 OpB();
			 E1();
		 }else if(c1 instanceof FinD) {
			 p--;
		 }else {
			 if(er==0) {
		   		  erreur1(3," ");
		   		  } 
		 }
/**********************************************Parenthese Ouvrante ********************************************************/
	 }else {
		 if(er==0) {
   		  erreur1(3," ");
   		  }
	 }
 }
 public void OpU() {
	 if(c1 instanceof OperateurU) {
		 
	 }
 }
 public void OpB() {
	 if(c1 instanceof OperateurB) {
		 
	 }
 }
 public void Var1() {
 if(c1 instanceof VariableD) {
		 
	 }	 
 }
 
    
    
    
    
    
    
    
    
    
    
    
    
    
    public Jeton suivant() {
    	Jeton j;
    	if( this.p <entree.size()) {
    		j=entree.get(this.p);
    		p++;
    	}else {
    	j=entree.get(this.p-1);
    	}
    	return j;
    }
    public JetonDeduction suivant1() {
    	JetonDeduction j;
    	if( this.p <entree1.size()) {
    		j=entree1.get(this.p);
    		p++;
    	}else {
    	j=entree1.get(this.p-1);
    	}
    	return j;
    }
    private void demontrerActionPerformed(java.awt.event.ActionEvent evt) throws ErreurFileVide {  
    	   
    	erreur.setText("");
    	if(option.getSelectedValue().equals("Resolution")) {
        // TODO add your handling code here:
    	entree= new ArrayList<Jeton>();
       s=editeur.getText();
      String code=divide(s);
      if(code.length()==0) {
    	  erreur(0," ");
    	  
      }else {
        lexicale(code);
        
        if(er==0) {
        	expression=new Expression();
        	this.p=0;
        	entree.add(new fin(" "));
        	number=1;
        
        	T();
        	
           //  expression.affiche();
             ecran1 = new javax.swing.JTextArea();
             ecran1.setPreferredSize(new Dimension(ecran1.getWidth(), 10000));
             affichage.setPreferredSize(new Dimension(200,200));
             affichage.setViewportView(ecran1);
             if(er==0) {
             resolution();
             }
        }
     
       
      }//fin du test de la page vide
    	}//fin de resolution
    	else {
    		/****************************************************Deduction **********************************************************************************/
    		entree1= new ArrayList<JetonDeduction>();
    	       s=editeur.getText();
    	      String code=divide(s);
    	      if(code.length()==0) {
    	    	  erreur(0," ");
    	    	  
    	      }else {
    	        lexicale1(code);
    	        if(er==0) {
    	        	
    	        	this.p=0; this.paren=0;
    	        	entree1.add(new FinD(" "));
    	        	S();
    	        	try {
    	        		if(er==0) {
    	        			entree1.remove(entree1.size()-1);
						parenthese();
    	        		}
					} catch (ErreurFileVide e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (ErreurPileVide e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
    	                }
    	      }
    	}//fin de la deduction naturelle
    }       
    static int precedence(JetonDeduction c){
 
           if(c instanceof Implication) {
                return 1;}
           else   if(c instanceof Ou) {
               return 2;}
           else   if(c instanceof Et) {
               return 3;}
           else   if(c instanceof NegationD) {
               return 4;}
           else {
        	   return -1;
           }
    }

    static File infixToPostFix(){

        File result = new Liste();
        Stack<JetonDeduction> stack = new Stack<>();
        for (int i = 0; i <entree1.size() ; i++) {
            JetonDeduction c = entree1.get(i);
          
            //check if char is operator
            if(precedence(c)>0){
            	 if(precedence(c)==1) {
            		
                while(stack.isEmpty()==false && precedence(stack.peek())>precedence(c)){
                	 JetonDeduction mmm=stack.pop();
                	
                	result.enfiler(mmm);
                }
                stack.push(c);}
            	 else {
            		    while(stack.isEmpty()==false && precedence(stack.peek())>=precedence(c)){
                            result.enfiler(stack.pop());
                        }
                        stack.push(c);	 
            	 }
            }else if(c instanceof ParentheseF){
            	 JetonDeduction x = stack.pop();
                while(!(x instanceof ParentheseO )){
                    result.enfiler(x);
                    x = stack.pop();
                }
            }else if(c instanceof ParentheseO){
                stack.push(c);
            }else{
                //character is neither operator nor ( 
                result.enfiler(c);
            }
        }
       while(stack.empty()==false) {
        	
        	 JetonDeduction mm=stack.pop();
        	
            result.enfiler(mm);
        }
        return result;
    }
                                 
          public void parenthese() throws ErreurFileVide, ErreurPileVide {
	         
	         for(int i=0;i<entree1.size();i++) {
	        	// entree1.get(i).affiche();
	         }
	     
	         b=infixToPostFix();
	         b.aff();
	     
	    Pile   p=new Liste(); File a=new Liste();
	    while(!this.b.vide()){
	    	JetonDeduction t=this.b.defiler();
	    	a.enfiler(t);             
	    if (t instanceof VariableD){
	    	Expression1 j=new Expression1(t.getval());
	    	j.ajouter(t);
	    	p.empiler(j);}
	    else{
	    	if (t instanceof OperateurB){
	    		JetonDeduction k=p.depiler();
	    		
	    		JetonDeduction j=p.depiler();
	    		Expression1 i=new Expression1(k.getval());
	    		       i.ajouter(new ParentheseF(")"));
	    				i.ajouter(k);
	    				i.ajouter(t);
	    				i.ajouter(j);
	    			     i.ajouter(new ParentheseO("("));
	    				
	    		  p.empiler(i);
	    	}
	    	else if(t instanceof OperateurU){
	    		JetonDeduction k=p.depiler();
	    		Expression1 j=new Expression1(k.getval());
	    		j.ajouter(k);
	    		j.ajouter(t);
	    	
	    		p.empiler(j);
	    	}
	    }
	    }
	    while(!a.vide()){  // cela permet de redonner a la file ses elements
	    	JetonDeduction y=a.defiler();
	    	this.b.enfiler(y);
	    }
	   
	    ArrayList<JetonDeduction>   entree2=new ArrayList<JetonDeduction>();
	    while(!p.vide()) {
	    	JetonDeduction y=p.depiler();
	    	entree2.add(y);
	    	//y.affiche();
	    
	    }
	    
	   
	    //for (int i = 0; i <entree2.size() ; i++) {
            JetonDeduction c = entree2.get(0);
         // c.affiche();
          /*JetonDeduction f = entree2.get(0).copy(); 
          ((Expression1) f).eliParenthese();
          f.affiche();//}
         ArrayList<JetonDeduction> decomp=  ((Expression1) f).decompose();
         System.out.println("La taille de la decomposition est "+decomp.size());
         Operateur o= ((Expression1) f).getOperateur();
         System.out.println("L'operateur est "+o.getval());
         System.out.println("on veut tester"+decomp.get(0).getval());
        ArrayList<JetonDeduction> decomp1=  ((Expression1) decomp.get(0)).decompose();
         System.out.println("La taille de la decomposition est "+decomp1.size()+" "+((Expression1) decomp.get(1)).isDecomposable()+" "+((Expression1) decomp.get(0)).getval());
        Operateur o1= ((Expression1) decomp.get(0)).getOperateur();
         System.out.println("L'operateur est "+o1.getval());
	    /****************** transformation ***************** ************/
         
         //creation arbre
         
         Node<Expression1> noeud=new Node<Expression1>((Expression1) entree2.get(0),"");
         //creation hypothese
         ArrayList<Node<Expression1>> b=new ArrayList<Node<Expression1>>();
         ArrayList<String> already=new ArrayList<String>();
         Bool tr1=new Bool();
         deduction(noeud,b,already,tr1,1);
         //printTree(noeud, " ");
       
          if(tr1.is()==true) {
         JPanel ecranp = new BinaryTreeView (noeud);
         ecranp.setPreferredSize(new Dimension(6000, 10000));
         affichage.setPreferredSize(new Dimension(6000,10000));

          affichage.setViewportView(ecranp);
          }else {
        	  
        	  erreur.append("La formule est fausse ");
          }
         /*******************************************************************/
              }//fin de la function parenthese
          
          public static void deduction(Node<Expression1> arbre,ArrayList<Node<Expression1>> hypothese,ArrayList<String> already,Bool trouve,int h) {
        	  if(!arbre.getData().isDecomposable()) {
                if(arbre.getData().getval().equals("⊥")) {
                	
                	boolean tr=demonstration(arbre,hypothese,already);
          		  trouve.set(tr);
          		
                }else {
                	 ArrayList<Node<Expression1>> c20=copyarbre(hypothese);
                	 ArrayList<String> already10=copy(already); 
                	boolean tr=demonstration(arbre,c20,already10);
                	
                	if(tr==true) {
            		  trouve.set(tr);
            		  hypothese=c20;
            		  already=already10;
            		 
                	}else {
                	 	   c20=copyarbre(hypothese);
                    	 already10=copy(already); 
                    	 /*****************/
                    	 Expression1 e20=new Expression1("");
                    	 e20.ajouter1(new NegationD("¬"));
                    	 e20.ajouter1((Expression1) arbre.getData());
                    	 
                    	 Node<Expression1> noeud=new Node<Expression1>(e20,"",h);
                    	 h++;
                   		       c20.add(noeud);
                   		    Expression1 e1=new Expression1("");
           			     e1.ajouter(new VariableD("⊥"));
           			     Node<Expression1> noeud4=new Node<Expression1>(e1,"");
                    	tr=demonstration(noeud4,c20,already10);
                    	
                    	if(tr==true) {
                    		 arbre.setOp("E⊥");
                		  trouve.set(tr);
                		  hypothese=c20;
                		  already=already10;
                		  arbre.addChild(noeud4);
                		  
                    	}else {
                		
                	boolean trou=false;
                	  ArrayList<Node<Expression1>> c1=copyarbre(hypothese);
                	for(int i=0;i<c1.size() && trou==false;i++) {
                		if(c1.get(i).getData().isDecomposable()) {
                			//on verifie que son operateur est un ou
                			if(c1.get(i).getData().getOperateur() instanceof Ou) {
                				  JetonDeduction f = c1.get(i).getData().copy(); 
                                  ((Expression1) f).eliParenthese();
                                 ArrayList<JetonDeduction> decomp=  ((Expression1) f).decompose();
                				//on a trouver un ou
 /*uuiuiiuiiiiiiiiiiiiiiiiiiii/******************************************************************/
                	    		  ArrayList<Node<Expression1>> c3=copyarbre(c1);
                        		  ArrayList<Node<Expression1>> c4=copyarbre(c1);
                        		  ArrayList<String> already1=copy(already); 
                        		  arbre.setOp("E∨");
                        		  
                                  noeud=new Node<Expression1>(arbre.getData(),"");
                                  noeud4=new Node<Expression1>(arbre.getData(),"");
                                 Node<Expression1> hyp=new Node<Expression1>((Expression1) decomp.get(0),"",h);
                                 h++;
                                 c3.add(hyp);
                                 boolean trouve1=demonstration(noeud,c3,already1);
                 			     Node<Expression1> hy4=new Node<Expression1>((Expression1) decomp.get(1),"",h);
                 			     h++;
                 			      c4.add(hy4);
                 			     ArrayList<String> already2=copy(already); 
                 			   
                 			    boolean trouve2= demonstration(noeud4,c4,already2);
                 			  
                 			     if(trouve1==true && trouve2==true ) {
                 			    	 already=already1;
                 			    	 hypothese=c3;
                 			    	 arbre.addChild(c1.get(i));
                 			    	 arbre.addChild(noeud);
                 			    	 arbre.addChild(noeud4);
                 			    	 trouve.setTrue();
                 	
                 			    	 trou=true;
                 			    }else if(trouve1==true){
                 			    	//already=already1;
                 			    	// hypothese=c4;
                 			    	//arbre.addChild(noeud);
                 			    	trouve.setFalse();
             /***************************************************************************/
                 		 	 	   c20=copyarbre(c4);
                              	 already10=copy(already); 
                              	 /*****************/
                              	       e20=new Expression1("");
                              	 e20.ajouter1(new NegationD("¬"));
                              	 e20.ajouter1((Expression1) arbre.getData());
                              	 
                              	 Node<Expression1> noeud20=new Node<Expression1>(e20,"",h);
                              	 h++;
                             		       c20.add(noeud20);
                             		    e1=new Expression1("");
                     			     e1.ajouter(new VariableD("⊥"));
                     			     Node<Expression1> noeud40=new Node<Expression1>(e1,"");
                              	tr=demonstration(noeud40,c20,already10);	    	
                 			    	if(tr==true) {
                 			    		 already=already10;
                     			    	 hypothese=c20;
                     			    	 noeud4.addChild(noeud40);
                     			    	 arbre.addChild(c1.get(i));
                     			    	 arbre.addChild(noeud);
                     			    	 arbre.addChild(noeud4);
                     			    	 trouve.setTrue();
                     			   	 trou=true;
                 			    	}
       /*********************************************************************************/          			    	
                 			    }else if(trouve2==true) {
                 			    	//already=already2;
                 			    	 //hypothese=c4;
                 			    	//arbre.addChild(noeud);
                 			    	trouve.setFalse();
                 		             /***************************************************************************/
                  		 	 	   c20=copyarbre(c3);
                               	 already10=copy(already); 
                               	 /*****************/
                               	       e20=new Expression1("");
                               	 e20.ajouter1(new NegationD("¬"));
                               	 e20.ajouter1((Expression1) arbre.getData());
                               	 
                               	 Node<Expression1> noeud20=new Node<Expression1>(e20,"",h);
                               	 h++;
                              		       c20.add(noeud20);
                              		    e1=new Expression1("");
                      			     e1.ajouter(new VariableD("⊥"));
                      			     Node<Expression1> noeud40=new Node<Expression1>(e1,"");
                               	tr=demonstration(noeud40,c20,already10);	    	
                  			    	if(tr==true) {
                  			    		
                  			    		 already=already10;
                      			    	 hypothese=c20;
                      			    	 noeud.addChild(noeud40);
                      			    	 arbre.addChild(c1.get(i));
                      			    	 arbre.addChild(noeud);
                      			    	 arbre.addChild(noeud4);
                      			    	 trouve.setTrue();
                      			  	 trou=true;
                  			    	}
        /*********************************************************************************/          			    	
                  		
                 			    }else {
                 			    	trouve.setFalse();
                 			    	 c20=copyarbre(c3);
                                  	 already10=copy(already1); 
                                  	 /*****************/
                                  	       e20=new Expression1("");
                                  	 e20.ajouter1(new NegationD("¬"));
                                  	 e20.ajouter1((Expression1) arbre.getData());
                                  	 
                                  	 Node<Expression1> noeud20=new Node<Expression1>(e20,"",h);
                                  	 h++;
                                 		       c20.add(noeud20);
                                 		    e1=new Expression1("");
                         			     e1.ajouter(new VariableD("⊥"));
                         			     Node<Expression1> noeud40=new Node<Expression1>(e1,"");
                                  	tr=demonstration(noeud40,c20,already10);
                                  	
                                  	/////////////////
                                  	already=already2;
                			    	 //hypothese=c4;
                			    	//arbre.addChild(noeud);
                			    	trouve.setFalse();
                		             /***************************************************************************/
                 		 	 	ArrayList<Node<Expression1>>   c21=copyarbre(c4);
                              	ArrayList<String> already11=copy(already2); 
                              	 /*****************/
                              	       e20=new Expression1("");
                              	 e20.ajouter1(new NegationD("¬"));
                              	 e20.ajouter1((Expression1) arbre.getData());
                              	 
                              	 Node<Expression1> noeud21=new Node<Expression1>(e20,"",h);
                              	 h++;
                             		       c21.add(noeud21);
                             		    e1=new Expression1("");
                     			     e1.ajouter(new VariableD("⊥"));
                     			     Node<Expression1> noeud41=new Node<Expression1>(e1,"");
                              	boolean tr1=demonstration(noeud41,c21,already11);
                                if(tr1==true && tr==true ) {
                			    	 already=already1;
                			    	 hypothese=c21;
                			    	 arbre.addChild(c1.get(i));
                			    	 noeud.addChild(noeud40);
                			    	 arbre.addChild(noeud);
                			    	 noeud4.addChild(noeud41);
                			    	 arbre.addChild(noeud4);
                			    	 trouve.setTrue();
                	
                			    	 trou=true;
                                }
                 			    }             				
                				
                				
                				
                				
                				
                				
                				
                				
                				
                				
                				
/*uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu*/////////////////////////////////////////////////////                				
                			}
                		}//on verifie qu'il est decomposable
                	}
                	}//fin de la negation
                     }//fin de tr==true
                	
                }//fin de on teste l'elomination du ou
        		  
        		
        	  }else if(arbre.getData().getOperateur() instanceof NegationD ) {
        		  arbre.setOp("I¬");
        		  Node<Expression1> noeud=new Node<Expression1>((Expression1) arbre.getData(),"",h);
        		  h++;
          		hypothese.add(noeud);
          		 Expression1 e1=new Expression1("");
			     e1.ajouter(new VariableD("⊥"));
			     Node<Expression1> noeud4=new Node<Expression1>(e1,"");
			     deduction(noeud4,hypothese,already,trouve,h);
			     arbre.addChild(noeud4);
        		  
        	  }else if(arbre.getData().getOperateur() instanceof Et ) {
        		 
        		  arbre.setOp("I∧");
        		  JetonDeduction f = arbre.getData().copy(); 
                  ((Expression1) f).eliParenthese();
                 ArrayList<JetonDeduction> decomp=  ((Expression1) f).decompose();
                 Node<Expression1> noeud=new Node<Expression1>((Expression1) decomp.get(0),"");
                 deduction(noeud,hypothese,already,trouve,h);
                 Bool trouve1=trouve;
 			     Node<Expression1> noeud4=new Node<Expression1>((Expression1) decomp.get(1),"");
 			     deduction(noeud4,hypothese,already,trouve,h);
 			    Bool trouve2=trouve;
			     if(trouve1.is()==true && trouve2.is()==true ) {
			    	 arbre.addChild(noeud);
			    arbre.addChild(noeud4);
			    trouve.setTrue();
			     }else {
			    	trouve.setFalse();
			    }
        		  
        	  }else if(arbre.getData().getOperateur() instanceof Ou ) {
        		  
        		  JetonDeduction f = arbre.getData().copy(); 
                  ((Expression1) f).eliParenthese();
                 ArrayList<JetonDeduction> decomp=  ((Expression1) f).decompose();
                 if((((Expression1) decomp.get(0)).oppose().equals(decomp.get(1).getval()))) {
                	
                	 arbre.setOp("te¬ ");
                 }else {
        		  ArrayList<Node<Expression1>> c1=copyarbre(hypothese);
        		  ArrayList<Node<Expression1>> c2=copyarbre(hypothese);
        		  ArrayList<String> already1=copy(already); 
        		  arbre.setOp("I∨");
        		  
                 Node<Expression1> noeud=new Node<Expression1>((Expression1) decomp.get(0),"");
                 Bool  trouve40 = new Bool();
                 deduction(noeud,c1,already1,trouve40,h);
                 
 			     Node<Expression1> noeud4=new Node<Expression1>((Expression1) decomp.get(1),"");
 			    ArrayList<String> already2=copy(already); 
 			    Bool trouve2=new Bool();
 			     deduction(noeud4,c2,already2,trouve2,h);
 			
 			  
 			     if(trouve40.is()==true && trouve2.is()==true ) {
 			    	 already=already1;
 			    	 hypothese=c1;
 			    	 arbre.addChild(noeud);
 			    	 trouve.setTrue();;
 			    }else if(trouve40.is()==true){
 			    	
 			    	already=already1;
 			    	 hypothese=c1;
 			    	arbre.addChild(noeud);
 			    	trouve.setTrue();
 			    }else if(trouve2.is()==true) {
 			    	already=already2;
 			    	 hypothese=c2;
 			    	arbre.addChild(noeud4);
 			    	trouve.setTrue();
 			    	
 			    }else {
 			    	trouve.setFalse();
 			    }
                 }//fin du test du tiers exclus
        	  }else {
        		 
        		  arbre.setOp("I⇒");
        		  JetonDeduction f = arbre.getData().copy(); 
                  ((Expression1) f).eliParenthese();
                 ArrayList<JetonDeduction> decomp=  ((Expression1) f).decompose();
                 Node<Expression1> noeud=new Node<Expression1>((Expression1) decomp.get(0),"",h);
                 h++;
           		hypothese.add(noeud);
 			     Node<Expression1> noeud4=new Node<Expression1>((Expression1) decomp.get(1),"");
 			     deduction(noeud4,hypothese,already,trouve,h);
 			     arbre.addChild(noeud4);
        		  
        	  }
        	   
  	    	
  	    } //deduction 
          
       public static boolean demonstration(Node<Expression1> arbre,ArrayList<Node<Expression1>> hypothese,ArrayList<String> already){
    	  
    	   majHypothese(hypothese,already); 
    	  
    	   boolean tr=false;
    	   for(int i=0;i<hypothese.size() && tr==false;i++) {
    		   System.out.println(hypothese.get(i).getData().getval());
    		   if(hypothese.get(i).getData().getval().equals(arbre.getData().getval())) {
    			   arbre.addChildren(hypothese.get(i).getChildren());
    			   arbre.setOp(hypothese.get(i).getOp());
    			   arbre.setHypo(hypothese.get(i).hypo());
    			   tr=true;
    		   }
    	   }
    	   return tr;
       }
       static int vv=0;
       public static void majHypothese(ArrayList<Node<Expression1>> h,ArrayList<String> already) {
    	   
    	   vv++;
    	   for(int nn=0,sizen = h.size()*h.size(); nn < sizen;nn++) {
    	   for(int i=0,size = h.size(); i < size;i++) {
    		  //already.add(i+"-"+i+"⇒");
    		     //already.add(i+"-"+i+"¬");
    		     //already.add(i+"-"+i+"∧");
    		   Expression1 copie=(Expression1) h.get(i).getData().copy();
    		   ((Expression1) copie).eliParenthese();
    		   ArrayList<JetonDeduction> decomp=null;
    		   if(copie.getOperateur()==null  || copie.getOperateur() instanceof NegationD) {
    			   
    		   }else {
    	        decomp=  ((Expression1) copie).decompose();
    		   }
    		   for(int j=0, size1 = h.size(); j < size1;j++) {
    		
    			     if(copie.getOperateur() instanceof Implication) {
    			   if(!recherche(already,Integer.toString(i),Integer.toString(j),"⇒")) {
    				   already.add(i+"-"+j+"⇒");
    				  if(decomp.get(0).getval().equals(h.get(j).getData().getval())) {
    					  Node<Expression1> noeud=new Node<Expression1>((Expression1) decomp.get(1),"E⇒");
    					  noeud.addChild(h.get(i));
    					  noeud.addChild(h.get(j));
    					  h.add(noeud);
    					
    				  }
    			   }
    			     }
    			     if(copie.getOperateur() instanceof NegationD) {
    			    	/* if(!recherche(already,copie.getval(),"","*")) {
    			    		 decomp=  ((Expression1) copie).decompose();
    	    				   already.add(copie.getval()+"*");
    	    				   Node<Expression1> noeud=new Node<Expression1>((Expression1) decomp.get(0),"def¬"); 
    	    				   noeud.addChild(h.get(i));
    	    				   h.add(noeud);	   
    			    	 }*/
    			   if(!recherche(already,Integer.toString(i),Integer.toString(j),"¬")) {
    				   already.add(i+"-"+j+"¬");
    				   
    				   if(((Expression1) copie).oppose().equals(h.get(j).getData().getval())) {
    					     Expression1 e1=new Expression1("");
    					     e1.ajouter(new VariableD("⊥"));
    					   Node<Expression1> noeud=new Node<Expression1>(e1,"E¬");
    					   noeud.addChild(h.get(i));
     					  noeud.addChild(h.get(j));
     					  h.add(noeud);
     					 
    				   }
    			   }
    			     }
    			     if(copie.getOperateur() instanceof Et) {
    			    //	 System.out.println(h.size()+" "+i+" "+j+" kygo"+decomp.get(0).getval()+" "+decomp.get(1).getval());
    			   if(!recherche(already,copie.getval(),"","∧")) {
    				   already.add(copie.getval()+"∧");
    				   Node<Expression1> noeud=new Node<Expression1>((Expression1) decomp.get(0),"E∧1"); 
    				   noeud.addChild(h.get(i));
    				   h.add(noeud);
    				   
    				   Node<Expression1> noeud1=new Node<Expression1>((Expression1) decomp.get(1),"E∧1"); 
    				   noeud1.addChild(h.get(i));
    				   h.add(noeud1);
    			   }
    			     }
    		   }
    	   }
    	   }
       }
       public static ArrayList<Node<Expression1>> copyarbre(ArrayList<Node<Expression1>> c){
    	   ArrayList<Node<Expression1>> b=new ArrayList<Node<Expression1>>();
    	   for(int i=0;i<c.size();i++) {
    		   b.add(c.get(i));
    	   }
    	   return b;
       }
       private static <T> void printTree(Node<T> node, String appender) {
    	  // System.out.println(appender + ((JetonDeduction) node.getData()).getval());
    	   node.getChildren().forEach(each ->  printTree(each, appender + appender));
    	 }
       
       private <T> int getHeight(Node<T> root){

    	    if (root.getChildren().size()==0) {
    	        return 1;
    	    }

    	    int height=0;
    	    //Iterate every child
    	    for (Node<T> childNode  : root.getChildren()) {

    	        //Get the height again
    	        int childHeight = getHeight(childNode);

    	        //Update if new high result
    	        if (childHeight>height) {
    	            height = childHeight;
    	        }
    	    }

    	    //Return highest point
    	    return height + 1;
    	}
       public static boolean recherche(ArrayList<String> already,String p,String j,String op) {
    	   boolean tr=false;
    	   String cond1,cond2;
    	   if(op.equals("∧")) {
    		    cond1=p+op;
        	    cond2=p+op;
    	   } else	   if(op.equals("*")) {
   		    cond1=p+op;
    	    cond2=p+op;
	   }
    	   
    	   else {
    	    cond1=p+"-"+j+op;
    	    cond2=j+"-"+p+op;
    	   }
    	   for(int i=0;i<already.size() && tr==false;i++) {
    		   if(already.get(i).equals(cond1)||already.get(i).equals(cond2)) {
    			   tr=true;
    		   }
    	   }
    	   return tr;
       }
       
       public static ArrayList<String> copy(ArrayList<String> already){
    	   ArrayList<String> c=new ArrayList<String>();
    	   for(int i=0;i<already.size();i++) {
    		   c.add(already.get(i));
    	   }
    	   return c;
       }//fin de copie
    private void implicationActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    	int caretPosition = editeur.getCaretPosition();
    	editeur.insert( "⇒",caretPosition);
    }                                           
    private void negationActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    	int caretPosition = editeur.getCaretPosition();
    	editeur.insert( "¬",caretPosition);
    }            
    private void ouActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    	int caretPosition = editeur.getCaretPosition();
    	editeur.insert( "∨",caretPosition);
    }                                           
    private void etActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    	int caretPosition = editeur.getCaretPosition();
    	editeur.insert( "∧",caretPosition);
    }                                           


    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
   
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Menu.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Menu().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify 
    ArrayList<Jeton> entree;
    static ArrayList<JetonDeduction> entree1;
    private String s;
     Expression expression;
     int er;
     int p;
     Jeton c;
     JetonDeduction c1;
     int number=1;
     Clause clause;
     int paren=0;
    File b;
    private javax.swing.JScrollPane affichage;
    private javax.swing.JButton demontrer;
    private javax.swing.JPanel ecran;
    private javax.swing.JTextArea  ecran1;
    private javax.swing.JTextArea editeur;
    private javax.swing.JTextArea erreur;
    private javax.swing.JButton et;
    private javax.swing.JButton implication;
    private javax.swing.JScrollPane menuOption;
    private javax.swing.JScrollPane menuediteur;
    private javax.swing.JScrollPane menuerreur;
    private javax.swing.JButton negation;
    private javax.swing.JList<String> option;
    private javax.swing.JButton ou;
    private javax.swing.JLabel titre;
    private javax.swing.JLabel titreErreur;
    // End of variables declaration                   
}

